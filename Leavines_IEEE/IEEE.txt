For Project 3 in Programming Languages, I had to write a program that runs an IEEE-754 Floating Point Converter. In detail the data I had to run for the IEEE were the Sign bit, the Exponent Field, and the Significand, and those three were in both Single precision and Double precision. The way I approached it is by first declaring a decimal that will be used as the user’s input. 

After I’ve declared the input, I then declared integers for the sign bit, and the rest of the integers for the declared as multiplication, division, exponent, and double exponent which were assigned to zero. After declaring the integers, I have declared strings for the remainder for single precision, another remainder for double precision, and binary reverse strings for both single and double precision. 

Once I had the decimal, integers, and strings declared, I then created a series if statements that had while loops nested in them. In detail, The first series of if then else statements takes us through the first procedure of performing IEEE-754 by first where the sign bit is 0 and while the input is less than one, I constantly keep multiplying the input by 2, while incrementing the multiplication counter. Once the sequence is over I add to both 127 and 1023 for both the Single and Double precision respectively for the exponent. Then while the exponent is greater than zero, I take the remainder I’ve declared exclusively for the Single Precision, and add to the exponent then use the division process that will get me the remainder, and then divided the exponent by two. Then I have created another while loop to where the exponent I have declared exclusively for double precision then went through the same procedure I did for the Single Precision remainder in the previous while loop. 

Then in the else if statement, I have stated it to where if the input is greater than zero and greater than or equal to one. Then inside it, I have assigned the sign bit to zero then created a while loop to where the input is greater than or equal to two to where the input will be divided by two and increment the division counter. Then I have created another while loop to where the exponent is greater than 0 and in it repeated the same procedure for the remainders for both the Single and Double Precision and the rest as described in the previous paragraph. 

Then, I have completed the series of if then else statements where x is assigned to what will return the absolute value of the user’s input, and assigned the sign bit to 1. Then I created a while loop where the user’s input is greater than or equal to 2 and in it divided the user’s input by two then incremented the division counter. then after the while loop, I assigned the exponents I have declared for both single and double precision to add the division counter to both 127 and 1023 respectively. Afterwards, I have created another while loop where the exponent is greater than zero, and in that while loop, I added the remainder and exponent for double precision and divided them by two to get the remainder, and divided the exponent for the double precision by two. 

After finishing the series of if statements containing while loops nested in them, I used the string I have declared to reverse the binary and assigned it to where the remainders are reversed. Afterwards, I have declared a string and an integer for the single precision mantissa, and assigned a double that gets the decimal part of the decimal number inputted by the user for the mantissa process. Then once I have assigned the decimal of the mantissa to be multiplied by two, I then created a while loop to where the integer of the mantissa I have declared for single precision to be less than 23 to where it will output the same length of zeros and ones from the website that was provided for debugging purposes. Then in the while loop, I have it to where if the decimal is greater than or equal to one, then the string I have declared for the single precision of mantissa will be added to one and the decimal part for the mantissa will be subtracted from what calculates the integral part of the decimal part otherwise the string will be added to zero. 

Once the procedure for getting the Single Precision is finished, I have then started to set up what will be the output of the Sign Bit, Exponent Field, and the Significand of it, once the user makes his or her input. Once finished, I then started coding the procedure for the Double Precision. For the Double Precsion, I have pretty much went through the similar procedure that I did for the Single Precision such as declaring a string for the Double Precision version of mantissa and having the count in the while loop being less than fifty two in order to match the same output base on the results we will get from the provided website we use for debugging purposes. 

Then at the end, I have created a function that will reverse the strings when outputted after the user makes his or her input.   
